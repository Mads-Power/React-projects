/// <reference types="node" />
import { ChildProcess } from 'child_process';
import ProjectWorkspace from './project_workspace';
import { createProcess, CreateShellProcessRequest, CreateCommandProcessRequest } from './Process';
export declare enum MessageType {
    noTests = 0,
    testResults = 1,
    unknown = 2,
    watchUsage = 3
}
export declare type RunnerProcessEvent = {
    name: 'commandSent';
    commandLine: string;
} | {
    name: 'processClose';
    code: number | null;
    signal: NodeJS.Signals | null;
} | {
    name: 'processExit';
    code: number | null;
    signal: NodeJS.Signals | null;
} | {
    name: 'executableJSON';
    data: unknown;
    noTestsFound?: boolean;
} | {
    name: 'executableStdErr';
    msg: Buffer;
    msgType: MessageType;
} | {
    name: 'executableOutput';
    msg: string;
} | {
    name: 'terminalError';
    error: string;
};
export declare type RunnerEventName = RunnerProcessEvent['name'];
export declare type CommandArgs = {
    args: string[];
    replace?: boolean;
};
export interface RunnerCommandOptions {
    collectCoverage?: boolean;
    noColor?: boolean;
    testNamePattern?: string;
    testFileNamePattern?: string;
    reporters?: string[];
    watchMode?: 'watch' | 'watch-all';
    /** either to append or replace the Runner process arguments */
    cmdArgs?: CommandArgs;
}
export declare type CommandProcessRunner = Omit<CreateCommandProcessRequest, 'args'> & {
    cmdOptions: RunnerCommandOptions;
};
export interface ShellProcessRunner extends CreateShellProcessRequest {
    cmdOptions?: RunnerCommandOptions;
    keepOpen?: boolean;
}
export declare type RunnerRequest = ShellProcessRunner | CommandProcessRunner;
export interface RunnerOptions {
    createProcess?: typeof createProcess;
    outputFileSuffix?: string;
}
export default class Runner {
    private emitter;
    private _createProcess;
    private prevMessageTypes;
    private _exited;
    debugprocess?: ChildProcess;
    outputPath: string;
    readonly workspace: ProjectWorkspace;
    readonly options?: RunnerOptions;
    readonly request: RunnerRequest;
    constructor(request: RunnerRequest, workspace: ProjectWorkspace, options?: RunnerOptions);
    get exited(): boolean;
    private _getArgs;
    private fire;
    onRunnerEvent(f: (event: RunnerProcessEvent) => void): void;
    private registerProcessListener;
    start(): void;
    /**
     * send command to an already started runner
     * @param runnerOptions
     */
    sendCommand(cmdOptions: RunnerCommandOptions, keepOpen?: boolean): void;
    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */
    private _parseOutput;
    runJestWithUpdateForSnapshots(completion: () => void, args?: string[]): void;
    closeProcess(): void;
    private findMessageType;
    private doResultsFollowNoTestsFoundMessage;
}
